
## Библиотека для формата BSON

### Введение

Важной задачей в промышленной разработке является сериализация и десериализация данных - перевод в формат,
отделенный от контекста исполнения. Это может быть сохранение на диске с целью последующего прочтения. Или пересылка
данных другому процессу.

Название происходит от того, что нелинейно (как минимум - иерархически) структурированные данные превращаются в последовательность
байтов и обратно. В английском языке для этих двух операций также часто используются названия `marshal` и `unmarshal`.

`protobuf`, `json`, `xml`, `avro`, `pickle` - это лишь некоторые из известных подходов. В каждом из них есть свои плюсы
и свои минусы.

В этом задании мы разработаем библиотеку для сериализации/десериализации с использованием формата [BSON](https://bsonspec.org).

Это бинарная вариация на тему более известного формата `JSON`.

`BSON` используется как формат для общения клиентов с `MongoDB`. И в его спецификации есть явные следы этого варианта использования -
это видно по типам полей.

Но его можно приспособить и для передачи данных в других целях, чем мы и займемся. Поэтому как таковая `MongoDB` для работы над заданием не нужна.
Но может быть полезной утилита `bsondump`, которая создана разработчиками `MongoDB` и которая распространяется как отдельный артефакт.

С ее помощью вы можете проверять, что ваш код действительно порождает то, что нужно.


### Общая схема сдачи

Вся работа состоит из набора инкрементальных заданий.

Каждое последующее - это шаг вперед на основе предыдущего. И набор тестов нарастает от задания к заданию. Чтобы отдельное задание
было зачтено, его тестовый набор должен быть пройден полностью.


### Задание 1

Базовая сериализация и десериализация.

В этом задании мы поддерживаем передачу данных из Python-приложения в Python-приложение.
И рассчитываем на то, что пользоваться нашей библиотекой будут аккуратно и корректно.

При сериализации на вход будут поступать только корректные и поддерживаемые структуры,
не будет никаких списков, явяляющихся элементами самих себя и т.п..

А при десериализации на вход придет только то, что является порождением корректной сериализации.

Реализуем модуль `bson`, в интерфейсе которого будут две функции:

- `marshal(data)` - принимающая словарь, подлежащий сериализации и возвращающая объект типа `bytes`

- `unmarshal(data)` - принимающая объект с интерфейсом объекта типа `bytes` и возвращающая десериализованный
словарь.

#### Простейшая сериализация

Самое простое, что можно передать функции `marshal` - это пустой словарь.

В терминах bson-спецификации это будет документом и такой простейший документ превратится в 5 - согласно (правилам)
[https://bsonspec.org/spec.html].

Сначала сработает правило:

```
document	::=	int32 e_list unsigned_byte(0)
```

а потом - вторая ветка правила

```
e_list	::=  element e_list	
             | ""
```

Правила мы читаем так:

- `document` - это `int32`, потом `e_list`, потом `unsigned_byte(0)`
- `int32` и `unsigned_byte(0)` - это базовые сущности
- `e_list` - это список элементов, возможно, что пустой (и в нашем случае так и есть)

В итоге получится такой набор байтов: `[5 0 0 0 0]`

#### Что-то более содержательное 

Давайте сериализуем словарь `{'name': 'vasya'}`. 

Здесь вступает в действие одно из правил для `element`:

```
element	::= signed_byte(2) e_name string 

e_name ::= cstring
string ::= int32 (byte*) unsigned_byte(0)
cstring	::= (byte*) unsigned_byte(0)
```

Обращаем внимание на детали. Имя элемента и его содержимое - это строки, но разные. У одной явно
указана длина, у другой нет. Это НЕ означает, что длина значения как-то более существенно ограничена,
чем длина ключа. Потому что размер документа - тоже `int32`. Но это означает, что в значении можно использовать
нулевой байт, а в ключе - нельзя.

Вне зависимости от того, почему оно так, нам следует придерживаться правил выбранного формата.

И надо не забыть про то, что длина документа поменялась.


#### Числовые типы

Вещественные мы хотим хранить в их бинарном представлении в элементе соответствующего типа (1).

Для целых есть два типа элемента - 32-битный (16) и 64-битный (18). Если число влезает в 32-бита,
будем использовать 32-битный, если нет - 64-битный (пока предполагаем, что в 64-битный числр точно влезет).


#### Логические и None 

У логического есть свои тип элемента (8). При десериализации пока будем считать, что там может быть только 0 или 1.

None соответствует тип элемента Null value (10).


#### `datetime`

В BSON есть отдельный тип элемента `UTC datatime` (9). В нем мы хотим сериализовать значения класса
`datatime` с указанным `tzinfo` в виде количества милисекунд с `00:00:00.000` 1 января 1970 года в зоне `UTC`.

Тут появляется ассиметрия. Мы храним только число милисекунд, но не храним саму исходную таймзону. Поэтому при десериализации
у нас всегда получится время в таймзоне `UTC`.


#### Байтовые наборы 

В BSON есть отдельный тип элемента `Binary data` (5). Он имеет свою внутреннюю структуру с многими подтипами.

Будем хранить в нем содержимое Python-объектов типа `bytes` и `bytearray`.

Будем использовать подтип `Generic binary subtype` (0).

И здесь тоже ассиметрия - мы не храним знание о исходном типе. Давайте произвольно примем решение о том, что при все
десериализуется в `bytes`.


#### Документы как значения

Было бы очень странно, если бы схема сериализации не поддерживала иерархичность. 

Тип элемента `Embedded document` (3) - именно про это. В нем мы будем хранить рекурсивно сериализованный
вложенный словарь.

И здесь мы так же считаем, что все с входными данными будет хорошо. Например, все ключи всех словарей на любых уровнях вложенности
будут строками.

Про глубину вложенности предполагаем, что она может быть ограниченно произвольной. Вложенное  во вложенное
вполне ожидаемо, а вот вложенность на 350 уровней - вряд ли.

И раз уж мы говорим о документах в целом - договоримся о порядке сериализации ключей. BSON не дает на этом счет никаких указаний.
Но нам хотелось бы определенности. Как минимум для того, чтобы два словаря с одинаковым набором пар ключ/значение гарантированно
порождали один и тот же бинарный образ.

Давайте порождать элементы каждого документа в лексикографическом порядке ("по алфавиту") его ключей.

Тут появляется другого рода ассиметрия. На этот раз можно взять бинарный образ, десериализовать его, потом снова сериализовать -
и получить в итоге другой бинарный образ, не совпадающий с оригиналом.


#### Списки и кортежи

И задействуем еще один тип элемента - `Array` (4).

В нем будем хранить списки и кортежи. При десериализации будем порождать списки.

Это может показаться не очень логичным. Ведь для набора байтов мы порождаем `bytes` - неизменяемый тип.

Обоснование такое - `bytes` действительно логичен именно тем, что он неизменяем. И по этой логике хорошо
бы и `Array` десериализовывать в кортежи. Но в Python-сообществе не прижилась идея использовать кортеж для
длинных наборов однородных элементов. А `Array` в BSON - это скорее именно про такой случаях. Небольшое число
разнородных - формально возможный вариант, но в BSON для этого все-таки больше подходит документ.

Заметим, что на бинарном уровне `Array` хранится фактически как документ с ключами '0', '1', `...`. И мы, конечно же,
в этот момент подумаем, а не переиспользовать ли здесь логику работы со словарями.

Конечно же, можно, но давайте не будем лексикографически упорядочивать ключи. Пусть они идут по возрастанию именно в числовой интерпретации.

### Задание 2

Базовая обработка ошибок

В первом задании мы сфокусировались на основной логике. Но в продакшен-коде этого мало. Нужна надежная
и продуманная обработка разных вариантов неожиданных входных данных.

Не всегда схожу очевидно, как же их обрабатывать. То есть как обрабатывать - вроде бы понятно. Бросать исключения.
Но всегда ли стоит это делать - это еще вопрос.

Понятно, что если мы пытаемся десериализовать набор байтов и он обрывается посреди какого-то значения - это явная проблема.

Но по ряду пуктов могут быть вопросы. Считать ли ошибкой сериализации нестроковый ключ в словаре или просто молча его пропустить ?

Или считать ли ошибкой десериализации встреченный тип элемента, который мы не поддерживаем при сериализации ?

На последний вопрос можно отвечать по-разному в зависимости от наших целей. Ожидаем ли мы прочитать именно сериализованный нами документ
или готовы принимать данные, порожденные кем-то еще ? В первом случае мы скорее увидим в таком неожиданном элементе признак того,
что нам на вход пришло что-то не то. А во втором скорее захотим обработать знакомые нам поля, молча проигнорировав незнакомые.

В этом задании мы реализуем базовую стратегию, которая будет работать по умолчанию.

Прежде, чем ее описать, опишем нашу иерархию исключений:

```
BsonError
- BsonMarshalError
-- BsonUnsupportedObjectError
-- BsonUnsupportedKeyError
--- BsonKeyWithZeroByteError
-- BsonInputTooBigError
--- BsonBinaryTooBigError
--- BsonIntegerTooBigError
--- BsonStringTooBigError
--- BsonDocumentTooBigError
-- BsonCycleDetectedError
- BsonUnmarshalError
-- BsonBrokenDataError
--- BsonIncorrectSizeError
--- BsonTooManyDataError
--- BsonNotEnoughDataError
--- BsonInvalidElementTypeError
--- BsonInvalidStringError
--- BsonStringSizeError
--- BsonInconsistentStringSizeError
--- BsonBadStringDataError
--- BsonBadKeyDataError
--- BsonRepeatedKeyDataError
--- BsonBadArrayIndexError
--- BsonInvalidBinarySubtypeError
```

#### Проверки при сериализации

Принципы проверки при сериализации:

- если на входе не словарь, то это `BsonUnsupportedObjectError`

- если попадается подлежащее сериализации значение неподдерживаемого типа, то это `BsonUnsupportedObjectError`

- если попадается подлежащий сериализации словарь с хотя бы одним нестроковым ключом, то это `BsonUnsupportedKeyError`

- если попадается подлежащий сериализации словарь со строковым ключом, содержащим хотя бы один нулевой байт в `UTF-8`,
то это `BsonKeyWithZeroByteError`

- если попадается целое число вне диапазона значений знакового 64-битового целого, то это `BsonIntegerTooBigError`

- если попадается подлежащая сериализации строка, переполняющая вместимость типа элемента `UTF-8 string`, то это `BsonStringTooBigError`

- если попадается подлежащий сериализации байтовый тип, переполняющий вместимость типа элемента `Binary data`, то это `BsonBinaryTooBigError`

- если в ходе сериализации переполняется вместимость типа элемента `BSON Document`, то это `BsonDocumentTooBigError`

- если попадается подлежащее сериализации значение, сериализацией которого мы сейчас уже занимаемся, то это `BsonCycleDetectedError`
-- 

При обработке каждого из документов сначала проверяются основания для `BsonUnsupportedKeyError` (в строгом смысле),
для `BsonKeyWithZeroByteError` и для `BsonUnsupportedObjectError` непосредственно в этом документе (без рекурсии) - именно в таком порядке.

Если во входном документе есть циклическая вложенность, то чисто технически ее можно игнорировать и упасть по `BsonDocumentTooBigError`.
Но мы так не хотим. Если есть циклическая зависимость, обнаруживаемая до того, как появились основания для `BsonInputTooBigError`,
то важно бросить именно `BsonCycleDetectedError`.

Проверка оснований для `BsonInputTooBigError` и наследников производится после завершения обработки каждой пары ключ-значение.
Например, если в документе очень-очень много пар ключ-значение, пусть и умеренной длины каждое, мы можем переполнить документ, не
успев обработать все ключи. И об этом надо сообщить именно после обрабтки той пары, которая все переполнила и не обрабатывать все, что
идет дальше.

Если появились основания для какого либо из `BsonInputTooBigError` и одновременно для `BsonDocumentTooBigError` применительно к одному
из объемлющих документов, то должно быть брошено исключение, касающееся элемента, а не объемлющего документа.

А про проверки во время десериализации будет следующее задание.


### Задание 3

#### Проверки при десериализации 

При десериализации документа в первую очередь проверяется наличие 4 байтов для хранения размера.

Если их нет - это `BsonBrokenDataError`.

Если они есть, то проверяется

- не меньше ли он минимально возможного в принципе. Если меньше - это `BsonIncorrectSizeError`

- равен ли он размеру поданных данных. Если меньше - это `BsonTooManyDataError`, если больше - это `BsonNotEnoughDataError`.

После этого идет обработка элементов входного документа.

Если любой из ключей не декодируется по правилам `UTF-8`, то это `BsonBadKeyDataError`.

Если любой из ключей словаря повторяется, то это `BsonRepeatedKeyDataError`

Если встретился тип элемента, не описанный в спецификации BSON, то это `BsonInvalidElementTypeError`.

Если встретился тип элемента, описанный в спецификации BSON, но тот, которые не порождается нами при сериализации, то мы его читаем
на общих основаниях, но никак не сохраняем.

Но мы должны проверить даже неподдерживаемый тип на корректность внутренней структуры. Например `JavaScript code with scope`
должен иметь в своем составе `document`, а `binary` - корректный `subtype`. В последнем случае должен бросаться
`BsonInvalidBinarySubtypeError`.

После чтения каждой пары ключ-значение, проверяем, не вышли ли мы за размер любого из объемлющих документов. Если вышли - это
`BsonBrokenDataError`.

Если в ходе десериализации значения типа элемента `UTF-8 string` выясняется, что заявленный размер строкового значения заведомо
некорректен, то это `BsonStringSizeError`. Аналогично с любым применением `string`.

Если этот размер вылезает за размер любого из объемлющих документов - это `BsonInconsistentStringSizeError`.

Если строка не декодируется по правилам `UTF-8`, то это `BsonBadStringDataError`.

Если после заявленного размера строки нет нулевого байта, то это `BsonBrokenDataError`.

Если после заявленного размера документа нет нулевого байта, то это `BsonBrokenDataError`.

При обработке типа элемента `Array`, помимо общих уже описанных проверок, мы также ждем, что там не будет нечисловых индексов.

А "дырки" в нумерации могут быть. Посколько общая идея в том, что принимаем документы, которые мог породить кто-то кроме нас,
то мы готовы к разным вариантам. Скорее всего такая организация `Array` пришла в `BSON` под влиянием `JavaScript`,
в котором могут быть такие дырки в индексах. То есть мы при десериализации должны вернуть массив, заполнив дырки None-ами.

Если же в массиве были нечисловые индексы, то это `BsonBadArrayIndexError`.


### Задание 4

Классовое API

Дальше мы хотим поиграть с разными настройками сериализации и десериализации.

Настраивать логику через параметры функций неудобно. Во-первых потому что параметров много.
Во-вторых, потому что часто нам в разных контекстах удобно разные конфигурации параметров считать
естественными и брать их в качестве умолчания.

Это значит, что нам нужно перейти к API в стиле ООП, хранить настройки в состоянии объекта и вызывать
основную логику через методы.

Назовем такой класс `Mapper` и пусть у него будут методы `marshal` и `unmarshal`.

Даже в таком нехитром классе есть место для применения особенностей ООП именно в Python-стиле.

Не хотелось бы фиксировать в API класса список парамеров конфигурации. Пусть конструктор принимает произвольное
число параметров, которые должны быть в обязательном порядке именованными.

Если передается параметр, не соответствующий поддерживаемой опции - должно быть брошено исключение `MapperUnsupportedOptionError`.

Если же передается, то оно перекрывает значение этого параметра по умолчанию. И далее оно доступно как свойство,
то есть без вызова метода, а все попытки его изменить или удалить должны порождать исключение.

То есть если вызвать конструктор совсем без параметров, то семантика вызываемых далее методов должна
быть точно эквивалентна вызовам функций.

Более того, нам вовсе НЕ нужно убирать из API модуля функции. Их логика должна переехать в методы класса, а в теле каждой из
функций должен появиться вызов соответствующего метода над объектом, созданным со значениями параметров по умолчанию.

Также в рамках этого задания поддержим первую опцию конфигурирования десериализации - `python_only`.

Смысл этой опции - в том, чтобы усилить проверки и принимать только те входы, которые могли быть порождены нашим же сериализатором.

Исключение сделаем только для двух случаев:

- ненулевое и неединичное значение логического типа будет воспринимать спокойно и превращать в `True`.

- значение элемента типа `int64`, укладывающееся в диапазон `int32`, тоже будем воспринимать спокойно.

В случае обнаружения типа элемента, который не мог быть порожден нашим кодом, в таком режиме должно быть брошено
исключение `BsonInvalidElementTypeError`.

Итак, по итогам этого задания должен появиться класс Mapper со следующими сценариями:

```
m = Mapper()
print(m.python_only) # False
```

```
m = Mapper()
m.python_only = True # порождает AttributeError
``` 

```
m = Mapper()
del m.python_only # порождает AttributeError 
``` 

```
m = Mapper(something=True) # порождает MapperConfigError
``` 

```
m = Mapper(True) # порождает исключение
``` 


```
m = Mapper(python_only=True)
print(m.python_only) # True 
``` 

```
m = Mapper(python_only=False)
print(m.python_only) # False 
``` 

На поведение сериализации флаг `python_only` не влияет.

Что касается десериализации:

- при значении False метод `unmarshal` ведет себя иак же, как и функция

- при значении True метод `unmarshal` начинает бросать дополнительные исключения, согласно описанию.

Также этот флаг влияет на интерпретацию бинарных полей и индексов в массиве.

При включенном `python_only` режиме считаем поводом к исключению любой бинарный подтип, кроме нулевого.

А для массивов заведем новое исключение - `BsonInvalidArrayError` - на тот случай, если режим `python_only`
был включен и мы обнаружили массив с "дырками" в индекcах.
  
