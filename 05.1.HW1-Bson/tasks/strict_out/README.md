
## Библиотека для формата BSON

### Введение

Важной задачей в промышленной разработке является сериализация и десериализация данных - перевод в формат,
отделенный от контекста исполнения. Это может быть сохранение на диске с целью последующего прочтения. Или пересылка
данных другому процессу.

Название происходит от того, что нелинейно (как минимум - иерархически) структурированные данные превращаются в последовательность
байтов и обратно. В английском языке для этих двух операций также часто используются названия `marshal` и `unmarshal`.

`protobuf`, `json`, `xml`, `avro`, `pickle` - это лишь некоторые из известных подходов. В каждом из них есть свои плюсы
и свои минусы.

В этом задании мы разработаем библиотеку для сериализации/десериализации с использованием формата [BSON](https://bsonspec.org).

Это бинарная вариация на тему более известного формата `JSON`.

`BSON` используется как формат для общения клиентов с `MongoDB`. И в его спецификации есть явные следы этого варианта использования -
это видно по типам полей.

Но его можно приспособить и для передачи данных в других целях, чем мы и займемся. Поэтому как таковая `MongoDB` для работы над заданием не нужна.
Но может быть полезной утилита `bsondump`, которая создана разработчиками `MongoDB` и которая распространяется как отдельный артефакт.

С ее помощью вы можете проверять, что ваш код действительно порождает то, что нужно.


### Общая схема сдачи

Вся работа состоит из набора инкрементальных заданий.

Каждое последующее - это шаг вперед на основе предыдущего. И набор тестов нарастает от задания к заданию. Чтобы отдельное задание
было зачтено, его тестовый набор должен быть пройден полностью.


### Задание 1

80 баллов

Базовая сериализация и десериализация.

В этом задании мы поддерживаем передачу данных из Python-приложения в Python-приложение.
И рассчитываем на то, что пользоваться нашей библиотекой будут аккуратно и корректно.

При сериализации на вход будут поступать только корректные и поддерживаемые структуры,
не будет никаких списков, явяляющихся элементами самих себя и т.п..

А при десериализации на вход придет только то, что является порождением корректной сериализации.

Реализуем модуль `bson`, в интерфейсе которого будут две функции:

- `marshal(data)` - принимающая словарь, подлежащий сериализации и возвращающая объект типа `bytes`

- `unmarshal(data)` - принимающая объект с интерфейсом объекта типа `bytes` и возвращающая десериализованный
словарь.

#### Простейшая сериализация

Самое простое, что можно передать функции `marshal` - это пустой словарь.

В терминах bson-спецификации это будет документом и такой простейший документ превратится в 5 - согласно (правилам)
[https://bsonspec.org/spec.html].

Сначала сработает правило:

```
document	::=	int32 e_list unsigned_byte(0)
```

а потом - вторая ветка правила

```
e_list	::=  element e_list	
             | ""
```

Правила мы читаем так:

- `document` - это `int32`, потом `e_list`, потом `unsigned_byte(0)`
- `int32` и `unsigned_byte(0)` - это базовые сущности
- `e_list` - это список элементов, возможно, что пустой (и в нашем случае так и есть)

В итоге получится такой набор байтов: `[5 0 0 0 0]`

#### Что-то более содержательное 

Давайте сериализуем словарь `{'name': 'vasya'}`. 

Здесь вступает в действие одно из правил для `element`:

```
element	::= signed_byte(2) e_name string 

e_name ::= cstring
string ::= int32 (byte*) unsigned_byte(0)
cstring	::= (byte*) unsigned_byte(0)
```

Обращаем внимание на детали. Имя элемента и его содержимое - это строки, но разные. У одной явно
указана длина, у другой нет. Это НЕ означает, что длина значения как-то более существенно ограничена,
чем длина ключа. Потому что размер документа - тоже `int32`. Но это означает, что в значении можно использовать
нулевой байт, а в ключе - нельзя.

Вне зависимости от того, почему оно так, нам следует придерживаться правил выбранного формата.

И надо не забыть про то, что длина документа поменялась.


#### Числовые типы

Вещественные мы хотим хранить в их бинарном представлении в элементе соответствующего типа (1).

Для целых есть два типа элемента - 32-битный (16) и 64-битный (18). Если число влезает в 32-бита,
будем использовать 32-битный, если нет - 64-битный (пока предполагаем, что в 64-битный числр точно влезет).


#### Логические и None 

У логического есть свои тип элемента (8). При десериализации пока будем считать, что там может быть только 0 или 1.

None соответствует тип элемента Null value (10).


#### `datetime`

В BSON есть отдельный тип элемента `UTC datatime` (9). В нем мы хотим сериализовать значения класса
`datatime` с указанным `tzinfo` в виде количества милисекунд с `00:00:00.000` 1 января 1970 года в зоне `UTC`.

Тут появляется ассиметрия. Мы храним только число милисекунд, но не храним саму исходную таймзону. Поэтому при десериализации
у нас всегда получится время в таймзоне `UTC`.


#### Байтовые наборы 

В BSON есть отдельный тип элемента `Binary data` (5). Он имеет свою внутреннюю структуру с многими подтипами.

Будем хранить в нем содержимое Python-объектов типа `bytes` и `bytearray`.

Будем использовать подтип `Generic binary subtype` (0).

И здесь тоже ассиметрия - мы не храним знание о исходном типе. Давайте произвольно примем решение о том, что при все
десериализуется в `bytes`.


#### Документы как значения

Было бы очень странно, если бы схема сериализации не поддерживала иерархичность. 

Тип элемента `Embedded document` (3) - именно про это. В нем мы будем хранить рекурсивно сериализованный
вложенный словарь.

И здесь мы так же считаем, что все с входными данными будет хорошо. Например, все ключи всех словарей на любых уровнях вложенности
будут строками.

Про глубину вложенности предполагаем, что она может быть ограниченно произвольной. Вложенное  во вложенное
вполне ожидаемо, а вот вложенность на 350 уровней - вряд ли.

И раз уж мы говорим о документах в целом - договоримся о порядке сериализации ключей. BSON не дает на этом счет никаких указаний.
Но нам хотелось бы определенности. Как минимум для того, чтобы два словаря с одинаковым набором пар ключ/значение гарантированно
порождали один и тот же бинарный образ.

Давайте порождать элементы каждого документа в лексикографическом порядке ("по алфавиту") его ключей.

Тут появляется другого рода ассиметрия. На этот раз можно взять бинарный образ, десериализовать его, потом снова сериализовать -
и получить в итоге другой бинарный образ, не совпадающий с оригиналом.


#### Списки и кортежи

И задействуем еще один тип элемента - `Array` (4).

В нем будем хранить списки и кортежи. При десериализации будем порождать списки.

Это может показаться не очень логичным. Ведь для набора байтов мы порождаем `bytes` - неизменяемый тип.

Обоснование такое - `bytes` действительно логичен именно тем, что он неизменяем. И по этой логике хорошо
бы и `Array` десериализовывать в кортежи. Но в Python-сообществе не прижилась идея использовать кортеж для
длинных наборов однородных элементов. А `Array` в BSON - это скорее именно про такой случаях. Небольшое число
разнородных - формально возможный вариант, но в BSON для этого все-таки больше подходит документ.

Заметим, что на бинарном уровне `Array` хранится фактически как документ с ключами '0', '1', `...`. И мы, конечно же,
в этот момент подумаем, а не переиспользовать ли здесь логику работы со словарями.

Конечно же, можно, но давайте не будем лексикографически упорядочивать ключи. Пусть они идут по возрастанию именно в числовой интерпретации.

### Задание 2

30 баллов

Базовая обработка ошибок

В первом задании мы сфокусировались на основной логике. Но в продакшен-коде этого мало. Нужна надежная
и продуманная обработка разных вариантов неожиданных входных данных.

Не всегда схожу очевидно, как же их обрабатывать. То есть как обрабатывать - вроде бы понятно. Бросать исключения.
Но всегда ли стоит это делать - это еще вопрос.

Понятно, что если мы пытаемся десериализовать набор байтов и он обрывается посреди какого-то значения - это явная проблема.

Но по ряду пуктов могут быть вопросы. Считать ли ошибкой сериализации нестроковый ключ в словаре или просто молча его пропустить ?

Или считать ли ошибкой десериализации встреченный тип элемента, который мы не поддерживаем при сериализации ?

На последний вопрос можно отвечать по-разному в зависимости от наших целей. Ожидаем ли мы прочитать именно сериализованный нами документ
или готовы принимать данные, порожденные кем-то еще ? В первом случае мы скорее увидим в таком неожиданном элементе признак того,
что нам на вход пришло что-то не то. А во втором скорее захотим обработать знакомые нам поля, молча проигнорировав незнакомые.

В этом задании мы реализуем базовую стратегию, которая будет работать по умолчанию.

Прежде, чем ее описать, опишем нашу иерархию исключений:

```
BsonError
- BsonMarshalError
-- BsonUnsupportedObjectError
-- BsonUnsupportedKeyError
--- BsonKeyWithZeroByteError
-- BsonInputTooBigError
--- BsonBinaryTooBigError
--- BsonIntegerTooBigError
--- BsonStringTooBigError
--- BsonDocumentTooBigError
-- BsonCycleDetectedError
- BsonUnmarshalError
-- BsonBrokenDataError
--- BsonIncorrentSizeError
--- BsonTooManyDataError
--- BsonNotEnoughDataError
--- BsonInvalidElementTypeError
--- BsonInvalidStringError
--- BsonStringSizeError
--- BsonInconsistentStringSizeError
--- BsonBadStringDataError
--- BsonBadKeyDataError
--- BsonRepeatedKeyDataError
--- BsonBadArrayIndexError
--- BsonInvalidBinarySubtypeError
```

#### Проверки при сериализации

Принципы проверки при сериализации:

- если на входе не словарь, то это `BsonUnsupportedObjectError`

- если попадается подлежащее сериализации значение неподдерживаемого типа, то это `BsonUnsupportedObjectError`

- если попадается подлежащий сериализации словарь с хотя бы одним нестроковым ключом, то это `BsonUnsupportedKeyError`

- если попадается подлежащий сериализации словарь со строковым ключом, содержащим хотя бы один нулевой байт в UTF-8,
то это `BsonKeyWithZeroByteError`

- если попадается целое число вне диапазона значений знакового 64-битового целого, то это `BsonIntegerTooBigError`

- если попадается подлежащая сериализации строка, переполняющая вместимость типа элемента `UTF-8 string`, то это `BsonStringTooBigError`

- если попадается подлежащий сериализации байтовый тип, переполняющий вместимость типа элемента `Binary data`, то это `BsonBinaryTooBigError`

- если в ходе сериализации переполняется вместимость типа элемента `BSON Document`, то это `BsonDocumentTooBigError`

- если попадается подлежащее сериализации значение, сериализацией которого мы сейчас уже занимаемся, то это `BsonCycleDetectedError`
-- 

При обработке каждого из документов сначала проверяются основания для `BsonUnsupportedKeyError` (в строгом смысле),
для `BsonKeyWithZeroByteError` и для `BsonUnsupportedObjectError` непосредственно в этом документе (без рекурсии) - именно в таком порядке.

Если во входном документе есть циклическая вложенность, то чисто технически ее можно игнорировать и упасть по `BsonDocumentTooBigError`.
Но мы так не хотим. Если есть циклическая зависимость, обнаруживаемая до того, как появились основания для `BsonInputTooBigError`,
то важно бросить именно `BsonCycleDetectedError`.

Проверка оснований для `BsonInputTooBigError` и наследников производится после завершения обработки каждой пары ключ-значение.
Например, если в документе очень-очень много пар ключ-значение, пусть и умеренной длины каждое, мы можем переполнить документ, не
успев обработать все ключи. И об этом надо сообщить именно после обрабтки той пары, которая все переполнила и не обрабатывать все, что
идет дальше.

Если появились основания для какого либо из `BsonInputTooBigError` и одновременно для `BsonDocumentTooBigError` применительно к одному
из объемлющих документов, то должно быть брошено исключение, касающееся элемента, а не объемлющего документа.

А про проверки во время десериализации будет следующее задание.

